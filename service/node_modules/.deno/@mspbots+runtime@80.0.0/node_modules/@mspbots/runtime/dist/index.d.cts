import { HonoRequest } from 'hono';

type Status = 'starting' | 'running' | 'crashed' | 'stopped';
interface Permissions {
    net?: string[] | boolean;
    read?: string[] | boolean;
    write?: string[] | boolean;
    env?: string[] | boolean;
    run?: string[] | boolean;
    ffi?: string[] | boolean;
    sys?: string[] | boolean;
    hrtime?: boolean;
    imports?: string[];
    kv?: boolean;
    http?: string[] | boolean;
    mspbots?: string[];
    db?: {
        type?: string;
        host?: string;
        port?: string | number;
        database?: string;
        user?: string;
        password?: string;
        [key: string]: unknown;
    };
    langchain?: {
        enabled: boolean;
        models?: string[];
        features?: string[];
    } | boolean;
    [key: string]: unknown;
}
interface Manifest {
    id: string;
    name: string;
    version: string;
    description?: string;
    icon?: string;
    permissions?: Permissions;
    metadata?: Record<string, unknown>;
    pages?: unknown[];
    imports?: string[];
    [key: string]: unknown;
}
interface Handle {
    worker: Worker;
    appId: string;
    status: Status;
    version: number;
    lastUsed: number;
    manifest: Manifest;
    importMapPath?: string;
    lockfilePath?: string;
}
interface Stats {
    appId: string;
    status: string;
    version: number;
    lastUsed: number;
    manifest?: Manifest;
}
interface Logger {
    error: (message: string, meta?: Record<string, unknown>) => void;
    warn: (message: string, meta?: Record<string, unknown>) => void;
    info: (message: string, meta?: Record<string, unknown>) => void;
    debug: (message: string, meta?: Record<string, unknown>) => void;
}
interface Config {
    appsDir?: string;
    scriptUrl?: string;
    timeout?: number;
    autoCleanup?: boolean;
    cleanupInterval?: number;
    maxIdle?: number;
    maxWorkers?: number;
    reuseWorkers?: boolean;
    workerReuseStrategy?: 'lru' | 'fifo' | 'none';
    enableQueue?: boolean;
    maxQueueSize?: number;
    queueTimeout?: number;
    logger?: Logger;
}
interface AppInfo {
    id: string;
    manifest?: Manifest;
    [key: string]: unknown;
}
interface User {
    id: string;
    name?: string;
    email?: string;
    [key: string]: unknown;
}
type PathParams = Record<string, string>;
type QueryValue$1 = string | string[];
type Query$1 = Record<string, QueryValue$1>;
interface RequestCtxBase {
    app: {
        id: string;
        name: string;
        version?: string;
        description?: string;
        icon?: string;
    };
    permissions: Record<string, unknown>;
    metadata: Record<string, unknown>;
    body: unknown;
    query: Query$1;
    params: PathParams;
    method: string;
    pathname: string;
    requestUrl: string;
    headers: Record<string, string>;
}
interface RequestCtxAuthed extends RequestCtxBase {
    user: User;
}
interface RequestCtxAnonymous extends RequestCtxBase {
    user?: undefined;
}
type RequestCtx = RequestCtxAuthed | RequestCtxAnonymous;
interface Payload {
    method: string;
    pathname: string;
    ctx: RequestCtx;
}
interface Response$1 {
    type: 'json' | 'raw';
    ok: boolean;
    body: unknown;
    status: number;
    headers: Record<string, string>;
}
interface HandlerParamsBase {
    id: string;
    name: string;
    version: string;
    description: string;
    metadata: Record<string, unknown>;
    headers: Record<string, string>;
    body: unknown;
    query: Query$1;
    params: PathParams;
    method: string;
    pathname: string;
    requestUrl: string;
}
interface HandlerParamsAuthed extends HandlerParamsBase {
    user: User;
}
interface HandlerParamsAnonymous extends HandlerParamsBase {
    user?: undefined;
}
type HandlerParams = HandlerParamsAuthed | HandlerParamsAnonymous;
type Handler<TParams extends HandlerParamsBase = HandlerParams> = (params: TParams) => unknown | Promise<unknown>;
interface AppModule {
    default?: Record<string, Handler>;
    [key: string]: unknown;
}
interface WorkerCtx {
    appId: string | null;
    [key: string]: unknown;
}
interface WorkerRuntimeContext {
    appId: string | null;
    manifest: Record<string, unknown> | null;
    appsDir: string | null;
    module: AppModule | null;
    serverPath?: string | null;
}

declare class Manager {
    private lifecycle;
    private messaging;
    private logger;
    private config;
    private stopCleanup?;
    private requestQueue;
    private queueProcessing;
    constructor(cfg?: Config);
    private getAppsDir;
    private getScriptUrl;
    ensure(info: AppInfo): Promise<Handle>;
    private evictIdle;
    private waitSlot;
    private processQueue;
    private loadManifest;
    invoke(payload: Payload): Promise<Response$1>;
    stop(id: string): Promise<void>;
    stopAll(): Promise<void>;
    restart(id: string): Promise<Handle>;
    getStats(): Stats[];
    getDetailedStats(): {
        lifecycle: {
            total: number;
            byStatus: {
                starting: number;
                running: number;
                crashed: number;
                stopped: number;
            };
            workers: {
                appId: string;
                status: Status;
                version: number;
                lastUsed: number;
                idle: number;
            }[];
        };
        pending: number;
        queue: {
            size: number;
            maxSize: number;
            enabled: boolean;
        };
        config: {
            appsDir: string;
            timeout: number;
            autoCleanup: boolean;
            maxWorkers: number;
            reuseWorkers: boolean;
            workerReuseStrategy: "lru" | "fifo" | "none";
            enableQueue: boolean;
            maxQueueSize: number;
            queueTimeout: number;
        };
        poolSize: number;
    };
    getPoolSize(): number;
    private startCleanup;
    private stopCleanupTask;
    cleanup(): Promise<void>;
    createClearCacheFunction(): (appId?: string) => Promise<void>;
}
declare function createManager(cfg?: Config): Manager;
declare function initManager(cfg: Config): void;
declare function ensureWorker(info: AppInfo): Promise<Handle>;
declare function invokeApp(payload: Payload): Promise<Response$1>;
declare function terminateWorker(id: string): void;
declare function terminateAllWorkers(): void;
declare function getWorkerStats(): Stats[];
declare function getWorkerManager(): Manager | null;
declare function stopWorker(id: string): Promise<void>;
declare function stopAllWorkers(): Promise<void>;

interface Events$1 {
    onCreate?: (handle: Handle) => void;
    onReady?: (handle: Handle) => void;
    onError?: (handle: Handle, error: Error) => void;
    onCrash?: (handle: Handle) => void;
    onStop?: (handle: Handle) => void;
}
interface Options {
    appsDir: string;
    timeout?: number;
    maxRetries?: number;
    hotReload?: boolean;
    platformImports?: Record<string, string>;
    libDir?: string;
}
declare class Lifecycle {
    private workers;
    private version;
    private events;
    private appsDir;
    private platformImportsOverride?;
    private libDir?;
    constructor(opts: Options, events?: Events$1);
    create(appId: string, manifest: Manifest, scriptUrl: string): Promise<Handle>;
    private createWorker;
    private createLock;
    private createImportMap;
    get(appId: string): Handle | undefined;
    getAll(): Handle[];
    getSize(): number;
    updateStatus(appId: string, status: Status): void;
    touch(appId: string): void;
    stop(appId: string): Promise<void>;
    private cleanupImportMap;
    private cleanupLock;
    stopAll(): Promise<void>;
    restart(appId: string, scriptUrl: string): Promise<Handle>;
    checkHealth(appId: string): {
        healthy: boolean;
        reason?: string;
    };
    cleanup(maxIdle?: number, maxToClean?: number): Promise<void>;
    stats(): {
        total: number;
        byStatus: {
            starting: number;
            running: number;
            crashed: number;
            stopped: number;
        };
        workers: Array<{
            appId: string;
            status: Status;
            version: number;
            lastUsed: number;
            idle: number;
        }>;
    };
    startCleanup(interval?: number, maxIdle?: number): () => void;
    private delay;
}
declare function createLifecycle(opts: Options, events?: Events$1): Lifecycle;

interface Events {
    onReady: (appId: string) => void;
    onLog: (appId: string, level: string, message: string, meta: unknown) => void;
    onResult: (appId: string, reqId: string, response: unknown) => void;
}
declare class Messaging {
    private pending;
    private seq;
    private events;
    private timeout;
    constructor(events: Events, timeout?: number);
    private nextId;
    setup(handle: Handle): void;
    sendInit(handle: Handle, appsDir: string, manifest: Manifest, serverPath?: string): void;
    sendInvoke(handle: Handle, payload: Payload): Promise<Response$1>;
    private rejectPending;
    cleanupTimeout(): void;
    getPendingCount(): number;
    getAppCount(appId: string): number;
    startCleanup(interval?: number): () => void;
}
declare function createMessaging(events: Events, timeout?: number): Messaging;

declare function pathExists(path: string): Promise<boolean>;
declare const defaultLogger: {
    error: (msg: string, meta?: Record<string, unknown>) => void;
    warn: (msg: string, meta?: Record<string, unknown>) => void;
    info: (msg: string, meta?: Record<string, unknown>) => void;
    debug: (msg: string, meta?: Record<string, unknown>) => void;
};

declare function extractUser(context: unknown): unknown;
declare function extractMetadata(context: unknown): Record<string, unknown>;
declare function extractAppInfo(appInfo: AppInfo | null): {
    id: string;
    name: string;
    version: string;
    description: string;
    icon: string;
};
declare function extractPermissions(appInfo: AppInfo | null): Record<string, unknown>;
declare function extractAppMetadata(appInfo: AppInfo | null): Record<string, unknown>;
declare function getAppLogMeta(appInfo: AppInfo | null): Record<string, unknown>;

declare function extractIdentifier(url: string): string;
declare function extractApi(fullPath: string, identifier: string): string;
declare function extractStatic(fullPath: string, identifier: string): string;
declare function findApp(identifier: string, getAppByName: (name: string) => Promise<AppInfo | null>): Promise<AppInfo | null>;
declare function createRequestCtx(appInfo: AppInfo, request: HonoRequest, method: string, path: string, user?: User | undefined, routePattern?: string): Promise<RequestCtx>;
declare function buildPayload(ctx: RequestCtx): Payload;
declare function handleResponse(workerResult: Response$1 | null, jsonResponse: (body: unknown, status: number) => Response): Response;
declare function handleError(error: Error, appInfo?: AppInfo | null): {
    status: number;
    body: Record<string, unknown>;
};

declare function clearModuleCache(appId?: string): Promise<void>;
declare function getCacheSize(): number;

declare function buildErrorResponse(error: Error, options?: {
    appInfo?: {
        id: string;
        manifest?: {
            name?: string;
        };
    } | null;
    status?: number;
    defaultMessage?: string;
}): {
    status: number;
    body: Record<string, unknown>;
};
declare function isWorkerCrashError(error: Error): boolean;
declare function parseBody(bodyText: string): unknown;
type QueryValue = string | string[];
type Query = Record<string, QueryValue>;
declare function parseQuery(url: string): Query;

declare function buildParams(ctx: RequestCtx, workerCtx: WorkerCtx): HandlerParams;

declare class PermManager {
    private manifest;
    private libDir;
    private platformImports;
    constructor(manifest: Manifest, libDir?: string, platformImports?: Record<string, string>);
    buildPerms(): Partial<Record<string, string[] | boolean>>;
    private normalize;
    getImports(): string[];
    private getLibPattern;
    getReadPaths(): string[];
    buildImportMap(platformImports: Record<string, string>): Record<string, string>;
    validateServerImports(appsDir: string): {
        valid: boolean;
        violations: string[];
        serverPath?: string;
    };
    validate(_platformImports?: Record<string, string>): {
        valid: boolean;
        errors: string[];
    };
}
declare function createPermManager(manifest: Manifest, libDir?: string, platformImports?: Record<string, string>): PermManager;

interface ExecutorConfig {
    appId: string;
    appsDir: string;
    scriptUrl: string;
    serverPath?: string;
    platformImports?: Record<string, string>;
    libDir?: string;
    logger?: Logger;
    timeout?: number;
}
declare class Executor {
    private lifecycle;
    private messaging;
    private config;
    private logger;
    private handle;
    constructor(config: ExecutorConfig);
    create(manifest: Manifest): Promise<void>;
    private waitForReady;
    invoke(payload: Payload): Promise<Response$1>;
    destroy(): Promise<void>;
    getStatus(): string;
}
declare function createExecutor(config: ExecutorConfig): Executor;

export { type AppInfo, type AppModule, type Config, type Events$1 as Events, Executor, type ExecutorConfig, type Handle, type Handler, type HandlerParams, type HandlerParamsAnonymous, type HandlerParamsAuthed, type HandlerParamsBase, Lifecycle, type Logger, Manager, type Manifest, Messaging, type Options, type PathParams, type Payload, PermManager, type Permissions, type Query$1 as Query, type QueryValue$1 as QueryValue, type RequestCtx, type RequestCtxAnonymous, type RequestCtxAuthed, type RequestCtxBase, type Response$1 as Response, type Stats, type Status, type User, type WorkerCtx, type WorkerRuntimeContext, buildErrorResponse, buildParams, buildPayload, clearModuleCache, createExecutor, createLifecycle, createManager, createMessaging, createPermManager, createRequestCtx, defaultLogger, ensureWorker, extractApi, extractAppInfo, extractAppMetadata, extractIdentifier, extractMetadata, extractPermissions, extractStatic, extractUser, findApp, getAppLogMeta, getCacheSize, getWorkerManager, getWorkerStats, handleError, handleResponse, initManager, invokeApp, isWorkerCrashError, parseBody, parseQuery, pathExists, stopAllWorkers, stopWorker, terminateAllWorkers, terminateWorker };
