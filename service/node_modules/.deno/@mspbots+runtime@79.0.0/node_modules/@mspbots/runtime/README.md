# @mspbots/runtime

Lightweight Deno/Node.js runtime environment for isolated execution of MSPBots backend service code.

| Package Info | Details |
| :--- | :--- |
| **Type** | Backend Package |
| **Environment** | Deno, Node.js |
| **Core Features** | Isolation, Permission Control |

## Operation Manual

### Introduction

This package is primarily used internally on the server side to load and run user-written `service/server.ts` code. It provides a sandbox environment ensuring applications can only access authorized APIs and resources.

### Key Features

1.  **Code Loading**: Dynamically loads the application's backend bundle.
2.  **Context Injection**: Injects `RequestCtx` for each request, containing user info, app config, etc.
3.  **API Routing**: Dispatches traffic to corresponding handler functions based on request path.
4.  **Permission Validation**: Validates API call permissions based on manifest declarations.

## API Reference

### Global Exports

The package exports core utilities and types for building the runtime environment.

```ts
export * from './manager';
export * from './types';
export * from './lifecycle';
export * from './messaging';
export * from './utils';
export * from './context';
export * from './http';
export * from './loader';
export * from './validator';
export * from './tools';
export * from './permissions';
export * from './executor';
```

### Core Interfaces

#### `HandlerParams`

The standard parameter object received by user-written route handlers.

```ts
export interface HandlerParams {
  // App identity
  id: string;           // App ID
  name: string;         // App name
  version: string;      // App version
  description: string;  // App description

  // App metadata (includes permissions snapshot)
  metadata: Record<string, unknown>; // Includes `permissions`

  // HTTP request data
  headers: Record<string, string>;                 // Lower-cased header keys
  body: unknown;                                   // Parsed JSON or raw string (see below)
  query: Record<string, string | string[]>;        // Query params (see below)
  params: Record<string, string>;                  // RESTful route params (see below)

  // Request context
  method: string;        // HTTP method
  pathname: string;      // Request pathname used for route matching
  requestUrl: string;    // Full request URL
  user?: User;           // Current user (if authenticated)
}
```

**REST routing & params parsing**

Routes are declared as a map in `service/server.ts`, keyed by `"<METHOD> <PATH_PATTERN>"`, for example:

```ts
const routes = {
  "GET /api/users/:id"({ params }: HandlerParams) {
    return { userId: params.id };
  },
  "GET /api/restful/:id/sub/:subId"({ params }: HandlerParams) {
    return params;
  },
  "GET /api/*"(p: HandlerParams) {
    return { path: p.pathname };
  },
};
export default routes;
```

- `params` is computed from the matched path pattern:
  - `:id` / `:subId` segments become keys in `params`
  - values are `decodeURIComponent`-decoded
  - wildcard `*` does not create a param key

**Query parsing**

`query` is derived from `URLSearchParams`:

- `?a=1` → `{ a: "1" }`
- `?a=1&a=2` → `{ a: ["1", "2"] }`

**Body parsing**

`body` is parsed from the raw request body text:

- empty body → `undefined`
- valid JSON → parsed object/array/value
- otherwise → raw string

**Headers**

`headers` keys are normalized to lowercase (e.g. `Authorization` becomes `authorization`).

#### `RequestCtx`

The raw context object passed into the runtime from the host server (e.g., mspack dev server or production gateway).

```ts
export interface RequestCtx {
  app: {
    id: string;
    name: string;
    version?: string;
    description?: string;
    icon?: string;
  };
  permissions: Record<string, unknown>;
  metadata: Record<string, unknown>;
  user?: User;
  
  // HTTP Request
  body: unknown;
  query: Record<string, string | string[]>;
  params: Record<string, string>;
  method: string;
  pathname: string;
  requestUrl: string;
  headers: Record<string, string>;
}
```

#### `Manifest` & `Permissions`

Defines the application's capabilities and metadata.

```ts
export interface Manifest {
  id: string;
  name: string;
  version: string;
  permissions?: Permissions;
  // ...
}

export interface Permissions {
  net?: string[] | boolean;  // Network access
  read?: string[] | boolean; // File read
  write?: string[] | boolean;// File write
  env?: string[] | boolean;  // Env vars
  run?: string[] | boolean;  // Subprocesses
  // ... and more (kv, db, langchain, etc.)
}
```

## Manifest & Permissions in mspack projects

In **mspack projects**, you typically configure the runtime manifest inside the project root `package.json` under the top-level `manifest` field (rather than hand-writing a separate `manifest.json`). During build, tooling may generate `dist/manifest.json` for publish/production usage.

### 1) Where the manifest comes from

- **Dev mode (mspack dev)**: mspack reads `package.json.manifest` and passes it into runtime (logs show `Manifest source: dev:package.json.manifest`).
- **Build output (mspack build)**: build can generate `dist/manifest.json`. Production runtime loads `manifest.json` from the app directory (logs look like `core:apps/<name>/manifest.json`).

### 2) The critical field: permissions.imports (mandatory allowlist)

If your `service/server.ts` imports external packages (npm/jsr), runtime performs a static pre-check before creating the worker. Only specifiers explicitly listed in `manifest.permissions.imports` are allowed. Otherwise you will see:

- `Unauthorized imports in <app>/server.js: <pkg>`

This works together with Deno import maps:

- `service/deno.json.imports`: available mappings (specifier -> actual source)
- `package.json` (`manifest.permissions.imports`): allowed specifiers (allowlist)

They must match. **If `service/deno.json.imports` contains `@mspbots/runtime` and your code imports it, then `manifest.permissions.imports` must include `@mspbots/runtime` as well.**

### 3) Quick checklist (when adding a backend dependency)

1. Add the mapping to `service/deno.json.imports` (or via `deno add npm:<pkg>`).
2. Add the same specifier to `package.json` under `manifest.permissions.imports`.
3. Ensure `permissions.imports` does not contain `*` (keep the allowlist minimal).

Notes:

- For scoped packages, include the full specifier (e.g., `@mspbots/runtime`), not just the scope.
- Runtime checks imports in `service/server.ts` (and its compiled output) against this allowlist.

### 4) React template example (recommended)

Template references:

- `service/deno.json`: [deno.json](file:///e:/mspbots/mb-platform-cli/templates/react/service/deno.json)
- `package.json`: [package.json](file:///e:/mspbots/mb-platform-cli/templates/react/package.json)

Keep them aligned like this:

```json
// service/deno.json
{
  "imports": {
    "@mspbots/runtime": "npm:@mspbots/runtime@9.0.0"
  }
}
```

```json
// package.json
{
  "manifest": {
    "permissions": {
      "kv": true,
      "imports": ["@mspbots/runtime"]
    }
  }
}
```

### 5) Can `imports` use `*`?

`permissions.imports` supports `*` meaning “allow all imports”. This greatly expands the permission surface and is not recommended for templates or real projects.

In `mspack update`, when the project already has `permissions.imports` (even an empty array), the merge logic will auto-fill missing entries based on `service/deno.json.imports` and ensure `*` is not kept, keeping the allowlist minimal.

### 6) Other common permissions

The `permissions` object follows Deno’s permission model and adds MSPBots-specific capabilities. Canonical types are defined in [types.ts](file:///e:/mspbots/mb-platform-cli/packages/runtime/types.ts).

#### 6.1 Core Deno permissions (common)

- `net?: boolean | string[]`: network access; `true` = unrestricted, `string[]` = allowlist
- `read?: boolean | string[]`: file read; `string[]` = allowed paths
- `write?: boolean | string[]`: file write; `string[]` = allowed paths
- `env?: boolean | string[]`: env vars; `string[]` = allowed variable names
- `run?: boolean | string[]`: subprocess; `string[]` = allowed commands
- `ffi?: boolean | string[]`: FFI dynamic library access
- `sys?: boolean | string[]`: system information access
- `hrtime?: boolean`: high-resolution time

#### 6.2 MSPBots-specific permissions

- `imports?: string[]`: package import allowlist (mandatory). Works with `service/deno.json.imports`
- `kv?: boolean`: KV capability toggle
- `http?: boolean | string[]`: HTTP capability; `string[]` can be used as a fine-grained allowlist (as interpreted by the platform)
- `mspbots?: string[]`: allowlist for platform built-in capabilities (names defined by the platform)
- `db?: { type?: string; host?: string; port?: string|number; database?: string; user?: string; password?: string; ... }`: database access config (validator requires at least `user/password`)
- `langchain?: boolean | { enabled: boolean; models?: string[]; features?: string[] }`: LangChain capability

#### 6.3 Minimal example

```json
{
  "manifest": {
    "permissions": {
      "kv": true,
      "imports": ["@mspbots/runtime"],
      "net": false,
      "read": ["./service"]
    }
  }
}
```

### Core Utilities

#### `buildParams(ctx: RequestCtx, workerCtx: WorkerCtx): HandlerParams`

Transforms the raw `RequestCtx` into the developer-facing `HandlerParams`.

#### `extractUser(context: unknown): unknown`

Helper to safely extract user information from a generic context object.

#### `extractAppInfo(appInfo: AppInfo | null)`

Helper to normalize application information from the raw manifest.
